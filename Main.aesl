<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->


<!--show keywords state-->
<keywords flag="false"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II">var Random1 #Random de -32767 à 32767
var Random #Random de 1 à 6
var Dice #Nombre de cases que le robot doit parcourir
var LC[8] #Leds du cercle
var LCD[8] #Leds du cercle allumées par le dé
var LCP[8] #Leds du cercle ayant été parcourues
var Compteur #Compte les lignes
var AllowD #Autorise le compteur à compter les lignes
var Longueur
var Largeur
var CheckReset

Longueur = 4 
Largeur = 2
callsub Init

############# Initialisation #############
sub Init
	Random1 = 0 #Reset de la valeur Random1
	Random = 0 #Reset de la valeur Random
	Dice = 0 #Réinitialise le dé
	Compteur = 0
	AllowD = 1
	callsub Arret
	
	
	call math.fill(LCP,0)	#Réinitialise les leds du cercle
	call math.fill(LCD,0)
	callsub Leds #Puissance des leds : 0
	
	timer.period[1]=0 #Timer du virage : Arrêt
	timer.period[0]=0 #Timer pour ignorer les lignes : Arrêt
return


############# Events #############

#Bouton central : Appèle la routine pour générer un nombre de 1 à 6
#Puis définit le nombre de case à avancer par ce nombre
onevent button.center
	when button.center == 1 do
		callsub RandomGen #Génère un nombre aléatoire de 1 à 6
		call math.fill(LCD,0) #Réinitialise les leds avant de générer le nombre aléatoire
		Dice = Random #Le robot doit avancer de Random cases
	end

#Bonton arrière : réinitialise le thymio
onevent button.backward
	callsub Init

#Met à jour les leds et compte les lignes
onevent motor
	callsub Leds
	callsub CompteLignes
	callsub Check
	
#Fait avancer le robot
onevent button.forward
	callsub Avant

#Timer pour ignorer les lignes pendant 2s ; s'arrête après activation
onevent timer0
	AllowD=1
	timer.period[0]=0



############# Routines #############



#Compare le nombre de lignes et fait arrêter le robot au besoin
sub Check
	#motor.left.target est utilisé pour remettre à zéro le when lorsque
	#le thymio se déplace, afin de faire en sorte que la condition
	#puisse être trigger à nouveau
	when Compteur>=Dice and motor.left.target>0 do
		callsub Arret
	end

#Empêche la première ligne d'être détectée pendant 2s
sub NoFirst
	AllowD=0
	timer.period[0]=1000

#À chaque fois que le thymio passe une ligne, ajoute 1 au compteur
#tant que AllowD==1 
sub CompteLignes
	when prox.ground.delta[1]&lt;750 do
		if AllowD==1 then
			Compteur++
		end return
	end
return

#Arrête les deux moteurs
sub Arret
	motor.right.target=0
	motor.left.target=0
return

#Met les deux moteurs à 100
sub Avant
	motor.left.target=100
	motor.right.target=100
	callsub NoFirst
return

#Allume les leds du compteur
sub Leds
	callsub LedsD
	#callsub LedsP
	LC[0:7]=LCD[0:7]+LCP[0:7]
	call leds.circle(LC[0],LC[1],LC[2],LC[3],LC[4],LC[5],LC[6],LC[7])
return

#Affiche le nombre sur les leds
sub LedsD
	if Dice&lt;=0 then #Si le dé=0, alors aucune led. 
	#Obligatoire, sinon crash pour accès à un secteur inexistant de l'array LCD lorsque Dice-1&lt;0
		call math.fill(LCD,0)
	elseif Dice>0 then #Si le dé>0, alors allumer la led correspondante
		call math.fill(LCD[abs(Dice-1)],1)
	end
return

#Génère la variable Random avec un nombre aléatoire de 1 à 6
sub RandomGen
	call math.rand( Random1 )
	Random = abs( Random1 % 6 ) + 1
return</node>


</network>
