<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="6" name="De"/>
<constant value="4" name="Longueur"/>
<constant value="2" name="Largeur"/>


<!--show keywords state-->
<keywords flag="false"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II">var Random1 #Random de -32767 à 32767
var Random #Random de 1 à 6
var Dice #Nombre de cases que le robot doit parcourir
var LC[8] #Leds du cercle
var LCD[8] #Leds du cercle allumées par le dé
var LCP[8] #Leds du cercle ayant été parcourues
var Compteur #Compte les lignes
var AllowD #Autorise le compteur à compter les lignes
var AllowDTimer #Timer pour AllowD
var Case
var tourneGauche[2]
var tourneDroite[2]
var timerRotate
var timerRotateTimer

callsub Init


############# Initialisation #############

sub Init
	Random1 = 0 #Reset de la valeur Random1
	Random = 0 #Reset de la valeur Random
	Dice = 0 #Réinitialise le dé
	Compteur = 0
	AllowD = 1
	AllowDTimer= 0
	timerRotate= 0
	timerRotateTimer = 0
	Case = 0
	
	callsub Arret
	
	
	call math.fill(LCP,0)	#Réinitialise les leds du cercle
	call math.fill(LCD,0)
	callsub Leds #Puissance des leds : 0
	
	timer.period[1]=0 #Timer du virage : Arrêt
	timer.period[0]=1 #Timer pour ignorer les lignes : Arrêt
	
	tourneGauche[0]=Longueur-1
	tourneGauche[1]=Longueur
	tourneDroite[0]=(Longueur*2)-1
	tourneDroite[1]=Longueur*2
return


############# Events #############

#Bouton central : Appèle la routine pour générer un nombre de 1 à 6
#Puis définit le nombre de case à avancer par ce nombre
onevent button.center
	when button.center == 1 do
		callsub RandomGen #Génère un nombre aléatoire de 1 à 6
		call math.fill(LCD,0) #Réinitialise les leds avant de générer le nombre aléatoire
		Dice = Random #Le robot doit avancer de Random cases
	end

#Bonton arrière : réinitialise le thymio
onevent button.backward
	callsub Init

#Met à jour les leds et compte les lignes
onevent motor
	callsub Leds
	callsub CompteLignes
	callsub Check
	callsub Tourne
	
#Fait avancer le robot
onevent button.forward
	callsub Avant
	
onevent button.left
	Case++

#Timer pour ignorer les lignes pendant 2s ; s'arrête après activation
onevent timer0
	if AllowD==0 then
		AllowDTimer++
	end
	if AllowDTimer>=2000 then
		AllowD=1
		AllowDTimer=0
	end
	if timerRotate==1 then
		timerRotateTimer++
	end
	if timerRotateTimer>=2200 then
		timerRotateTimer=0
		timerRotate=0
		callsub Arret
	end



############# Routines #############


sub Tourne
	when Case%tourneGauche[0]==0 and Case>0 do
		call leds.bottom.left(100,100,100)
		callsub tourneGauche
	end
	when Case%tourneGauche[1]==0 and Case>0 do
		call leds.bottom.left(100,100,100)
		callsub tourneGauche
	end
	when Case%tourneDroite[0]==0 and Case>0 do
		call leds.bottom.left(100,100,100)
		callsub tourneDroite
	end
	when Case%tourneDroite[1]==0 and Case>0 do
		call leds.bottom.left(100,100,100)
		callsub tourneDroite
	end
return


sub tourneGauche
	AllowD=0
	motor.left.target=-100
	motor.right.target=100
	timerRotate=1
return

sub tourneDroite
	
return

#Compare le nombre de lignes et fait arrêter le robot au besoin
sub Check
	#motor.left.target est utilisé pour remettre à zéro le when lorsque
	#le thymio se déplace, afin de faire en sorte que la condition
	#puisse être trigger à nouveau
	when Compteur>=Dice and motor.left.target>0 do
		callsub Arret
	end

#Empêche la première ligne d'être détectée pendant 2s
sub NoFirst
	AllowD=0
	AllowDTimer=0
return

#À chaque fois que le thymio passe une ligne, ajoute 1 au compteur
#tant que AllowD==1 
sub CompteLignes
	when prox.ground.delta[1]&lt;750 do
		if AllowD==1 then
			Compteur++
			Case++
		end return
	end
return

#Arrête les deux moteurs
sub Arret
	motor.right.target=0
	motor.left.target=0
return

#Met les deux moteurs à 100
sub Avant
	motor.left.target=100
	motor.right.target=100
	callsub NoFirst
return

#Allume les leds du compteur
sub Leds
	callsub LedsD
	callsub LedsP
	LC[0:7]=LCD[0:7]+LCP[0:7]
	call leds.circle(LC[0],LC[1],LC[2],LC[3],LC[4],LC[5],LC[6],LC[7])
return

#Allume le nombre de leds parcouru. Un peu bricolage mais math.fill ne supporte
#pas de variable comme argument de tableau :c
sub LedsP
	if Compteur>=1 then
		call math.fill(LCP[0],10)
	end
	if Compteur>=2 then
		call math.fill(LCP[0:1],10)
	end
	if Compteur>=3 then
		call math.fill(LCP[0:2],10)
	end
	if Compteur>=4 then
		call math.fill(LCP[0:3],10)
	end
	if Compteur>=5 then
		call math.fill(LCP[0:4],10)
	end
	if Compteur>=6 then
		call math.fill(LCP[0:5],10)
	end
	if Compteur>=7 then
		call math.fill(LCP[0:6],10)
	end
return

#Affiche le nombre sur les leds
sub LedsD
	if Dice&lt;=0 then #Si le dé=0, alors aucune led. 
	#Obligatoire, sinon crash pour accès à un secteur inexistant de l'array LCD lorsque Dice-1&lt;0
		call math.fill(LCD,0)
	elseif Dice>0 then #Si le dé>0, alors allumer la led correspondante
		call math.fill(LCD[abs(Dice-1)],1)
	end
return

#Génère la variable Random avec un nombre aléatoire de 1 à 6
sub RandomGen
	call math.rand( Random1 )
	Random = abs( Random1 % De ) + 1
return
</node>


</network>
